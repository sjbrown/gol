#! /usr/bin/env python
# encoding: utf-8
"""
Using the rules of Conway's Game of Life, this script generates
a cache file, "rules_cache.py", of the rules as a simple map.
The cache looks like this:

rules = {
 0b000000000: 0,
#        ╳╳╳  ╳╳╳
#        ╳╳╳  ╳╳╳
#        ╳╳╳  ╳╳╳

 0b000000001: 0,
#        ╳╳╳  ╳╳╳
#        ╳╳╳  ╳╳╳
#        ╳╳█  ╳╳█

 0b000000010: 0,
#        ╳╳╳  ╳╳╳
#        ╳╳╳  ╳╳╳
#        ╳█╳  ╳█╳

...

 0b111000000: 1,
#        ███  ███
#        ╳╳╳  ╳█╳
#        ╳╳╳  ╳╳╳


...etc.

 0b111111111: 0,
#        ███  ███
#        ███  █╳█
#        ███  ███

}

"""

import codecs
import doctest
import itertools


def living_neighbors(group):
    """
    group is an array of size 9, containing just 1s and 0s.

    >>> living_neighbors([0,0,0,0,0,0,0,0,0])
    0
    >>> living_neighbors([1,0,0,0,0,0,0,0,0])
    1
    >>> living_neighbors([1,0,0,0,1,0,0,0,0])
    1
    >>> living_neighbors([1,1,1,1,1,1,1,1,1])
    8
    """
    new_group = group[:] # Make a copy
    new_group.pop(4) # Pop out the middle one
    return sum(new_group)

def live_or_die(group):
    """
    >>> live_or_die([0,0,0,0,0,0,0,0,0])
    0
    >>> live_or_die([1,1,0,0,1,0,0,0,0])
    1
    >>> live_or_die([1,1,1,0,1,0,0,0,0])
    1
    >>> live_or_die([1,1,1,1,1,0,0,0,0])
    0
    """
    count = living_neighbors(group)
    this_cell_alive = group[4]
    if this_cell_alive:
        if count < 2: # Underpopulation
            return 0
        if count > 3: # Overpopulation
            return 0
        return 1
    if count == 3:
        return 1
    return 0

def make_stamp(group):
    str_repr = ''.join(str(x) for x in group)
    stamp = str_repr.replace('0', u'╳').replace('1', u'█')
    return stamp

def encode_to_rule(group):
    str_repr = ''.join(str(x) for x in group)
    g_stamp = make_stamp(group)
    r_stamp = make_stamp(group[:4] + [live_or_die(group)] + group[5:])

    rule = u' 0b{}: {},\n'.format(str_repr, live_or_die(group))

    # These "stamps" make it easy to quickly understand what each
    # rule does.
    rule += u'#        {}  {}\n'.format(g_stamp[:3], r_stamp[:3])
    rule += u'#        {}  {}\n'.format(g_stamp[3:6], r_stamp[3:6])
    rule += u'#        {}  {}\n'.format(g_stamp[6:], r_stamp[6:])
    rule += u'\n'
    return rule

def generate_all_possible_3x3_groups():
    """
    yields [0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,1], ...etc
    """
    for tupGroup in itertools.product([0,1], repeat=9):
        yield list(tupGroup)

def main():
    with codecs.open('rules_cache.py', 'wb', encoding='utf-8') as fp:
        fp.write(u'#! /usr/bin/env python\n')
        fp.write(u'# encoding: utf-8\n')
        fp.write(u'\n')
        fp.write(u'# !!! DO NOT EDIT - This file is automatically generated\n')
        fp.write(u'\n')
        fp.write(u'rules = {\n')

        for group in generate_all_possible_3x3_groups():
            fp.write(encode_to_rule(group))

        fp.write('}\n')

if __name__ == '__main__':
    doctest.testmod()
    main()
